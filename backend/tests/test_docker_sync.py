import hashlib
import os
import subprocess
import unittest

class TestDockerSync(unittest.TestCase):
    def test_ensure_latest_docker_build(self):
        """
        Checks if the Docker image is up-to-date with the latest backend code.
        If not, rebuilds and restarts the container.
        """
        # 1. Define paths
        # test_docker_sync.py is in backend/tests/
        tests_dir = os.path.dirname(os.path.abspath(__file__))
        backend_dir = os.path.dirname(tests_dir) # backend/
        project_root = os.path.dirname(backend_dir) # root of repo
        
        docker_compose_file = os.path.join(project_root, "docker-compose.yml")
        
        # Verify we are on a system where we can run docker commands
        if not os.path.exists(docker_compose_file):
            print("docker-compose.yml not found. Assuming we are not in the root context or inside a container.")
            # If we are inside the container, we probably shouldn't be running this test to rebuild the container.
            # But the user asked for this test.
            # We skip if we can't find the compose file.
            self.skipTest("docker-compose.yml not found.")

        # 2. Calculate hash of backend/ files
        # We verify if code has changed.
        current_hash = self.calculate_directory_hash(backend_dir)
        
        # 3. Read stored hash
        hash_file_path = os.path.join(backend_dir, ".docker_build_hash")
        stored_hash = ""
        if os.path.exists(hash_file_path):
            with open(hash_file_path, "r") as f:
                stored_hash = f.read().strip()
                
        # 4. Compare and Act
        if current_hash != stored_hash:
            print(f"Hash mismatch! Current: {current_hash[:8]}..., Stored: {stored_hash[:8]}...")
            print("Triggering Docker rebuild...")
            
            try:
                # Build
                # We use check=True to raise exception on failure
                subprocess.run(["docker-compose", "build", "app"], cwd=project_root, check=True)
                
                # Up
                subprocess.run(["docker-compose", "up", "-d", "app"], cwd=project_root, check=True)
                
                # Update hash file
                with open(hash_file_path, "w") as f:
                    f.write(current_hash)
                    
                print("Docker updated and hash saved.")
            except subprocess.CalledProcessError as e:
                self.fail(f"Docker command failed: {e}")
            except FileNotFoundError:
                 self.skipTest("docker-compose command not found.")
        else:
            print("Docker image is up-to-date with source code.")

    def calculate_directory_hash(self, directory):
        sha = hashlib.sha256()
        for root, dirs, files in os.walk(directory):
            # Sort to ensure consistent order
            dirs.sort()
            files.sort()
            
            # Exclude specific directories
            if "__pycache__" in dirs:
                dirs.remove("__pycache__")
            if ".pytest_cache" in dirs:
                dirs.remove(".pytest_cache")
            if ".git" in dirs:
                dirs.remove(".git")
            if "tests" in dirs:
                # We might want to include tests in the hash if we want to rebuild on test changes,
                # but usually we care about app code. 
                # Keeping tests for now as user said "latest code".
                pass
                
            for file in files:
                # Exclude .docker_build_hash itself
                if file == ".docker_build_hash":
                    continue
                # Exclude OS files
                if file == ".DS_Store":
                    continue
                # Exclude compiled python
                if file.endswith(".pyc"):
                    continue
                # Exclude databases and logs
                if file.endswith(".db") or file.endswith(".log"):
                    continue
                # Exclude metadata that changes often or is generated by tests
                if file.startswith(".mcp"):
                    continue
                if file.startswith("TEST_") or file.startswith("CONSISTENCY_"):
                    continue
                if file == "features_implemented.md":
                    continue

                filepath = os.path.join(root, file)
                try:
                    # Update hash with relative path (structure changes matter)
                    relpath = os.path.relpath(filepath, directory)
                    sha.update(relpath.encode('utf-8'))
                    
                    with open(filepath, 'rb') as f:
                        while True:
                            # Read in chunks
                            chunk = f.read(4096)
                            if not chunk:
                                break
                            sha.update(chunk)
                except OSError:
                    pass
        return sha.hexdigest()

if __name__ == "__main__":
    unittest.main()
