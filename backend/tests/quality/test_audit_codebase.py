import sys
import os
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "../../")))
import os
import re
import pytest

# Configuration
# File is in backend/tests/quality/
SEARCH_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), "../../"))
OUTPUT_FILE = os.path.abspath(os.path.join(SEARCH_ROOT, "../docs/reports/audit_mocks.md"))
EXCLUDE_DIRS = {".git", ".pytest_cache", "__pycache__", "venv", "env", "node_modules", ".gemini", "tests", "test-data"}
# Exclude the audit test itself, and known safe files
EXCLUDE_FILES = {
    "test_audit_codebase.py", "audit_mocks_hardcoded.md", "README.txt", "requirements.txt", ".DS_Store", 
    "debug_run.py", "refactor_chapters.py", "verify_fix.py", "generate_templates.py", "debug_keys.py",
    "verify_chapter_0.py"
}
EXTENSIONS = {".py", ".js", ".ts", ".tsx", ".html", ".css"}

PATTERNS = [
    (r"mock", "Mock Data/Functionality"),
    (r"dummy", "Dummy Data"),
    (r"hardcoded", "Hardcoded Item"),
    (r"TODO", "TODO Item"),
    (r"FIXME", "FIXME Item"),
    (r"placeholder", "Placeholder"),
    (r"print\(", "Leftover Print Debugging"), # production code should use logging
    (r"Lorem Ipsum", "Latin Placeholder Text"),
    # Avoid matching 'bar' in 'foo-bar' (common in CSS) by using negative lookarounds for dashes
    (r"(?<!-)\bfoo\b(?!-)|(?<!-)\bbar\b(?!-)|(?<!-)\bbaz\b(?!-)", "Generic Variable Name"),
]

def scan_file(filepath):
    findings = []
    filename = os.path.basename(filepath)
    is_html = filename.lower().endswith('.html')

    try:
        with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
            lines = f.readlines()
            for i, line in enumerate(lines):
                for pattern, label in PATTERNS:
                    # Special Case: 'placeholder' in HTML is usually a valid attribute
                    if is_html and label == "Placeholder" and "placeholder=" in line:
                        continue
                    
                    if re.search(pattern, line, re.IGNORECASE):
                        findings.append({
                            "file": filepath,
                            "line": i + 1,
                            "content": line.strip(),
                            "type": label
                        })
    except Exception as e:
        print(f"Error reading {filepath}: {e}")
    return findings

def test_audit_codebase_for_mocks_and_hardcoded_items():
    """
    Scans the codebase for mock data, hardcoded items, TODOs, etc.
    Writes findings to audit_mocks_hardcoded.md.
    """
    
    all_findings = []
    
    for root, dirs, files in os.walk(SEARCH_ROOT):
        # Filter directories
        dirs[:] = [d for d in dirs if d not in EXCLUDE_DIRS]
        
        for file in files:
            if file in EXCLUDE_FILES:
                continue
            # Exclude strict test files
            if file.startswith("test_"):
                continue
            
            if not any(file.endswith(ext) for ext in EXTENSIONS):
                continue
            
            filepath = os.path.join(root, file)
            all_findings.extend(scan_file(filepath))

    # Write Report
    with open(OUTPUT_FILE, "w", encoding="utf-8") as f:
        f.write("# Audit Report: Mocks, Hardcoded Items, and TODOs\n\n")
        f.write(f"*Generated by automated test execution.*\n\n")
        
        if not all_findings:
            f.write("âœ… **No issues found in audited files.**\n")
        else:
            f.write(f"Found **{len(all_findings)}** potential issues.\n\n")
            
            # Group by file
            files_dict = {}
            for item in all_findings:
                if item['file'] not in files_dict:
                    files_dict[item['file']] = []
                files_dict[item['file']].append(item)
            
            for filepath, items in files_dict.items():
                relpath = os.path.relpath(filepath, SEARCH_ROOT)
                f.write(f"### ðŸ“„ `{relpath}`\n")
                f.write("| Line | Type | Content |\n")
                f.write("| :--- | :--- | :--- |\n")
                for item in items:
                    # Escape pipes in content to avoid breaking the table
                    safe_content = item['content'].replace("|", "\|").replace("`", "'")
                    # Truncate very long lines
                    if len(safe_content) > 100:
                        safe_content = safe_content[:97] + "..."
                        
                    f.write(f"| {item['line']} | **{item['type']}** | `{safe_content}` |\n")
                f.write("\n")

    # Assert success - User requested ONLY reporting to MD file, not failing the test.
    issue_count = len(all_findings)
    if issue_count > 0:
        print(f"Audit found {issue_count} items. See {OUTPUT_FILE} for details.")
    else:
        print("Audit passed with no findings.")

if __name__ == "__main__":
    # Allow running this script directly
    test_audit_codebase_for_mocks_and_hardcoded_items()
